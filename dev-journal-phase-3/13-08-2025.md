# 📅 Dev Journal – 2025-08-13

## ✅ Progress

### 🔁 Asynchronous Notification Integration

- Implemented **notification update mechanism** using **RabbitMQ**, extending the async architecture:
  - After inference completes image embedding and insertion to Qdrant, it **publishes a notification update** back to the queue
  - Backend service now has a **RabbitMQ consumer** that listens for notification update messages and marks the corresponding notification as `read: false`
  - This enables the **frontend** to fetch and display new notifications dynamically

- Affected all 3 services:
  - 🧠 **Inference Service**: publishes message to `embedding_result` queue upon task completion
  - 🚀 **Backend Service**: added consumer to listen and update MongoDB notification document
  - 💻 **Frontend**: displays notification UI, red dot indicator for unread, and polling logic

- Verified full notification lifecycle:
  - Upload photo → embedding complete → user receives "New!" notification in frontend

## 🔜 Next Up

###  Storage Migration

- Migrate from local disk to **MinIO**



###  Code Quality & Architecture

- Refactor backend and inference services:
  - Break down long functions into reusable units
  - Separate concerns (e.g., MQ handling, business logic, I/O)
  - Improve logging and error handling for robustness

- Fully integrate Go’s `context.Context`:
  - Apply context to RabbitMQ producers/consumers, MinIO uploads, and MongoDB ops
  - Enable timeout and cancellation handling for better control and observability

###  Notification System Enhancements

- Make notifications real-time via WebSocket or SSE (optional)
- Add click-to-mark-as-read functionality in frontend

---
